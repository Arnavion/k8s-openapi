<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src/v1_34/apiextensions_apiserver/pkg/apis/apiextensions/v1/validation_rule.rs`."><title>validation_rule.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../../../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../../../../../../" data-static-root-path="../../../../../../../../static.files/" data-current-crate="k8s_openapi" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (523d3999d 2025-08-30)" data-channel="nightly" data-search-js="search-03d23683.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../../../../../../../static.files/storage-e2aeef58.js"></script><script defer src="../../../../../../../../static.files/src-script-813739b1.js"></script><script defer src="../../../../../../../../src-files.js"></script><script defer src="../../../../../../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../../../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><section id="main-content" class="content"><div class="main-heading"><h1><div class="sub-heading">k8s_openapi/v1_34/apiextensions_apiserver/pkg/apis/apiextensions/v1/</div>validation_rule.rs</h1><rustdoc-toolbar></rustdoc-toolbar></div><div class="example-wrap digits-3"><pre class="rust"><code><a href=#1 id=1 data-nosnippet>1</a><span class="comment">// Generated from definition io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.ValidationRule
<a href=#2 id=2 data-nosnippet>2</a>
<a href=#3 id=3 data-nosnippet>3</a></span><span class="doccomment">/// ValidationRule describes a validation rule written in the CEL expression language.
<a href=#4 id=4 data-nosnippet>4</a></span><span class="attr">#[derive(Clone, Debug, Default, PartialEq)]
<a href=#5 id=5 data-nosnippet>5</a></span><span class="kw">pub struct </span>ValidationRule {
<a href=#6 id=6 data-nosnippet>6</a>    <span class="doccomment">/// fieldPath represents the field path returned when the validation fails. It must be a relative JSON path (i.e. with array notation) scoped to the location of this x-kubernetes-validations extension in the schema and refer to an existing field. e.g. when validation checks if a specific attribute `foo` under a map `testMap`, the fieldPath could be set to `.testMap.foo` If the validation checks two lists must have unique attributes, the fieldPath could be set to either of the list: e.g. `.testList` It does not support list numeric index. It supports child operation to refer to an existing field currently. Refer to \[JSONPath support in Kubernetes\](https://kubernetes.io/docs/reference/kubectl/jsonpath/) for more info. Numeric index of array is not supported. For field name which contains special characters, use `\['specialName'\]` to refer the field name. e.g. for attribute `foo.34$` appears in a list `testList`, the fieldPath could be set to `.testList\['foo.34$'\]`
<a href=#7 id=7 data-nosnippet>7</a>    </span><span class="kw">pub </span>field_path: <span class="prelude-ty">Option</span>&lt;std::string::String&gt;,
<a href=#8 id=8 data-nosnippet>8</a>
<a href=#9 id=9 data-nosnippet>9</a>    <span class="doccomment">/// Message represents the message displayed when validation fails. The message is required if the Rule contains line breaks. The message must not contain line breaks. If unset, the message is "failed rule: {Rule}". e.g. "must be a URL with the host matching spec.host"
<a href=#10 id=10 data-nosnippet>10</a>    </span><span class="kw">pub </span>message: <span class="prelude-ty">Option</span>&lt;std::string::String&gt;,
<a href=#11 id=11 data-nosnippet>11</a>
<a href=#12 id=12 data-nosnippet>12</a>    <span class="doccomment">/// MessageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails. Since messageExpression is used as a failure message, it must evaluate to a string. If both message and messageExpression are present on a rule, then messageExpression will be used if validation fails. If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged. messageExpression has access to all the same variables as the rule; the only difference is the return type. Example: "x must be less than max ("+string(self.max)+")"
<a href=#13 id=13 data-nosnippet>13</a>    </span><span class="kw">pub </span>message_expression: <span class="prelude-ty">Option</span>&lt;std::string::String&gt;,
<a href=#14 id=14 data-nosnippet>14</a>
<a href=#15 id=15 data-nosnippet>15</a>    <span class="doccomment">/// optionalOldSelf is used to opt a transition rule into evaluation even when the object is first created, or if the old object is missing the value.
<a href=#16 id=16 data-nosnippet>16</a>    ///
<a href=#17 id=17 data-nosnippet>17</a>    /// When enabled `oldSelf` will be a CEL optional whose value will be `None` if there is no old value, or when the object is initially created.
<a href=#18 id=18 data-nosnippet>18</a>    ///
<a href=#19 id=19 data-nosnippet>19</a>    /// You may check for presence of oldSelf using `oldSelf.hasValue()` and unwrap it after checking using `oldSelf.value()`. Check the CEL documentation for Optional types for more information: https://pkg.go.dev/github.com/google/cel-go/cel#OptionalTypes
<a href=#20 id=20 data-nosnippet>20</a>    ///
<a href=#21 id=21 data-nosnippet>21</a>    /// May not be set unless `oldSelf` is used in `rule`.
<a href=#22 id=22 data-nosnippet>22</a>    </span><span class="kw">pub </span>optional_old_self: <span class="prelude-ty">Option</span>&lt;bool&gt;,
<a href=#23 id=23 data-nosnippet>23</a>
<a href=#24 id=24 data-nosnippet>24</a>    <span class="doccomment">/// reason provides a machine-readable validation failure reason that is returned to the caller when a request fails this validation rule. The HTTP status code returned to the caller will match the reason of the reason of the first failed validation rule. The currently supported reasons are: "FieldValueInvalid", "FieldValueForbidden", "FieldValueRequired", "FieldValueDuplicate". If not set, default to use "FieldValueInvalid". All future added reasons must be accepted by clients when reading this value and unknown reasons should be treated as FieldValueInvalid.
<a href=#25 id=25 data-nosnippet>25</a>    </span><span class="kw">pub </span>reason: <span class="prelude-ty">Option</span>&lt;std::string::String&gt;,
<a href=#26 id=26 data-nosnippet>26</a>
<a href=#27 id=27 data-nosnippet>27</a>    <span class="doccomment">/// Rule represents the expression which will be evaluated by CEL. ref: https://github.com/google/cel-spec The Rule is scoped to the location of the x-kubernetes-validations extension in the schema. The `self` variable in the CEL expression is bound to the scoped value. Example: - Rule scoped to the root of a resource with a status subresource: {"rule": "self.status.actual \&lt;= self.spec.maxDesired"}
<a href=#28 id=28 data-nosnippet>28</a>    ///
<a href=#29 id=29 data-nosnippet>29</a>    /// If the Rule is scoped to an object with properties, the accessible properties of the object are field selectable via `self.field` and field presence can be checked via `has(self.field)`. Null valued fields are treated as absent fields in CEL expressions. If the Rule is scoped to an object with additionalProperties (i.e. a map) the value of the map are accessible via `self\[mapKey\]`, map containment can be checked via `mapKey in self` and all entries of the map are accessible via CEL macros and functions such as `self.all(...)`. If the Rule is scoped to an array, the elements of the array are accessible via `self\[i\]` and also by macros and functions. If the Rule is scoped to a scalar, `self` is bound to the scalar value. Examples: - Rule scoped to a map of objects: {"rule": "self.components\['Widget'\].priority \&lt; 10"} - Rule scoped to a list of integers: {"rule": "self.values.all(value, value \&gt;= 0 &amp;&amp; value \&lt; 100)"} - Rule scoped to a string value: {"rule": "self.startsWith('kube')"}
<a href=#30 id=30 data-nosnippet>30</a>    ///
<a href=#31 id=31 data-nosnippet>31</a>    /// The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the object and from any x-kubernetes-embedded-resource annotated objects. No other metadata properties are accessible.
<a href=#32 id=32 data-nosnippet>32</a>    ///
<a href=#33 id=33 data-nosnippet>33</a>    /// Unknown data preserved in custom resources via x-kubernetes-preserve-unknown-fields is not accessible in CEL expressions. This includes: - Unknown field values that are preserved by object schemas with x-kubernetes-preserve-unknown-fields. - Object properties where the property schema is of an "unknown type". An "unknown type" is recursively defined as:
<a href=#34 id=34 data-nosnippet>34</a>    ///   - A schema with no type and x-kubernetes-preserve-unknown-fields set to true
<a href=#35 id=35 data-nosnippet>35</a>    ///   - An array where the items schema is of an "unknown type"
<a href=#36 id=36 data-nosnippet>36</a>    ///   - An object where the additionalProperties schema is of an "unknown type"
<a href=#37 id=37 data-nosnippet>37</a>    ///
<a href=#38 id=38 data-nosnippet>38</a>    /// Only property names of the form `\[a-zA-Z_.-/\]\[a-zA-Z0-9_.-/\]*` are accessible. Accessible property names are escaped according to the following rules when accessed in the expression: - '__' escapes to '__underscores__' - '.' escapes to '__dot__' - '-' escapes to '__dash__' - '/' escapes to '__slash__' - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
<a href=#39 id=39 data-nosnippet>39</a>    ///       "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
<a href=#40 id=40 data-nosnippet>40</a>    ///       "import", "let", "loop", "package", "namespace", "return".
<a href=#41 id=41 data-nosnippet>41</a>    /// Examples:
<a href=#42 id=42 data-nosnippet>42</a>    ///   - Rule accessing a property named "namespace": {"rule": "self.__namespace__ \&gt; 0"}
<a href=#43 id=43 data-nosnippet>43</a>    ///   - Rule accessing a property named "x-prop": {"rule": "self.x__dash__prop \&gt; 0"}
<a href=#44 id=44 data-nosnippet>44</a>    ///   - Rule accessing a property named "redact__d": {"rule": "self.redact__underscores__d \&gt; 0"}
<a href=#45 id=45 data-nosnippet>45</a>    ///
<a href=#46 id=46 data-nosnippet>46</a>    /// Equality on arrays with x-kubernetes-list-type of 'set' or 'map' ignores element order, i.e. \[1, 2\] == \[2, 1\]. Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
<a href=#47 id=47 data-nosnippet>47</a>    ///   - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
<a href=#48 id=48 data-nosnippet>48</a>    ///     non-intersecting elements in `Y` are appended, retaining their partial order.
<a href=#49 id=49 data-nosnippet>49</a>    ///   - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
<a href=#50 id=50 data-nosnippet>50</a>    ///     are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
<a href=#51 id=51 data-nosnippet>51</a>    ///     non-intersecting keys are appended, retaining their partial order.
<a href=#52 id=52 data-nosnippet>52</a>    ///
<a href=#53 id=53 data-nosnippet>53</a>    /// If `rule` makes use of the `oldSelf` variable it is implicitly a `transition rule`.
<a href=#54 id=54 data-nosnippet>54</a>    ///
<a href=#55 id=55 data-nosnippet>55</a>    /// By default, the `oldSelf` variable is the same type as `self`. When `optionalOldSelf` is true, the `oldSelf` variable is a CEL optional
<a href=#56 id=56 data-nosnippet>56</a>    ///  variable whose value() is the same type as `self`.
<a href=#57 id=57 data-nosnippet>57</a>    /// See the documentation for the `optionalOldSelf` field for details.
<a href=#58 id=58 data-nosnippet>58</a>    ///
<a href=#59 id=59 data-nosnippet>59</a>    /// Transition rules by default are applied only on UPDATE requests and are skipped if an old value could not be found. You can opt a transition rule into unconditional evaluation by setting `optionalOldSelf` to true.
<a href=#60 id=60 data-nosnippet>60</a>    </span><span class="kw">pub </span>rule: std::string::String,
<a href=#61 id=61 data-nosnippet>61</a>}
<a href=#62 id=62 data-nosnippet>62</a>
<a href=#63 id=63 data-nosnippet>63</a><span class="kw">impl </span><span class="kw">crate</span>::DeepMerge <span class="kw">for </span>ValidationRule {
<a href=#64 id=64 data-nosnippet>64</a>    <span class="kw">fn </span>merge_from(<span class="kw-2">&amp;mut </span><span class="self">self</span>, other: <span class="self">Self</span>) {
<a href=#65 id=65 data-nosnippet>65</a>        <span class="kw">crate</span>::DeepMerge::merge_from(<span class="kw-2">&amp;mut </span><span class="self">self</span>.field_path, other.field_path);
<a href=#66 id=66 data-nosnippet>66</a>        <span class="kw">crate</span>::DeepMerge::merge_from(<span class="kw-2">&amp;mut </span><span class="self">self</span>.message, other.message);
<a href=#67 id=67 data-nosnippet>67</a>        <span class="kw">crate</span>::DeepMerge::merge_from(<span class="kw-2">&amp;mut </span><span class="self">self</span>.message_expression, other.message_expression);
<a href=#68 id=68 data-nosnippet>68</a>        <span class="kw">crate</span>::DeepMerge::merge_from(<span class="kw-2">&amp;mut </span><span class="self">self</span>.optional_old_self, other.optional_old_self);
<a href=#69 id=69 data-nosnippet>69</a>        <span class="kw">crate</span>::DeepMerge::merge_from(<span class="kw-2">&amp;mut </span><span class="self">self</span>.reason, other.reason);
<a href=#70 id=70 data-nosnippet>70</a>        <span class="kw">crate</span>::DeepMerge::merge_from(<span class="kw-2">&amp;mut </span><span class="self">self</span>.rule, other.rule);
<a href=#71 id=71 data-nosnippet>71</a>    }
<a href=#72 id=72 data-nosnippet>72</a>}
<a href=#73 id=73 data-nosnippet>73</a>
<a href=#74 id=74 data-nosnippet>74</a><span class="kw">impl</span>&lt;<span class="lifetime">'de</span>&gt; <span class="kw">crate</span>::serde::Deserialize&lt;<span class="lifetime">'de</span>&gt; <span class="kw">for </span>ValidationRule {
<a href=#75 id=75 data-nosnippet>75</a>    <span class="kw">fn </span>deserialize&lt;D&gt;(deserializer: D) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, D::Error&gt; <span class="kw">where </span>D: <span class="kw">crate</span>::serde::Deserializer&lt;<span class="lifetime">'de</span>&gt; {
<a href=#76 id=76 data-nosnippet>76</a>        <span class="attr">#[allow(non_camel_case_types)]
<a href=#77 id=77 data-nosnippet>77</a>        </span><span class="kw">enum </span>Field {
<a href=#78 id=78 data-nosnippet>78</a>            Key_field_path,
<a href=#79 id=79 data-nosnippet>79</a>            Key_message,
<a href=#80 id=80 data-nosnippet>80</a>            Key_message_expression,
<a href=#81 id=81 data-nosnippet>81</a>            Key_optional_old_self,
<a href=#82 id=82 data-nosnippet>82</a>            Key_reason,
<a href=#83 id=83 data-nosnippet>83</a>            Key_rule,
<a href=#84 id=84 data-nosnippet>84</a>            Other,
<a href=#85 id=85 data-nosnippet>85</a>        }
<a href=#86 id=86 data-nosnippet>86</a>
<a href=#87 id=87 data-nosnippet>87</a>        <span class="kw">impl</span>&lt;<span class="lifetime">'de</span>&gt; <span class="kw">crate</span>::serde::Deserialize&lt;<span class="lifetime">'de</span>&gt; <span class="kw">for </span>Field {
<a href=#88 id=88 data-nosnippet>88</a>            <span class="kw">fn </span>deserialize&lt;D&gt;(deserializer: D) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, D::Error&gt; <span class="kw">where </span>D: <span class="kw">crate</span>::serde::Deserializer&lt;<span class="lifetime">'de</span>&gt; {
<a href=#89 id=89 data-nosnippet>89</a>                <span class="kw">struct </span>Visitor;
<a href=#90 id=90 data-nosnippet>90</a>
<a href=#91 id=91 data-nosnippet>91</a>                <span class="kw">impl </span><span class="kw">crate</span>::serde::de::Visitor&lt;<span class="lifetime">'_</span>&gt; <span class="kw">for </span>Visitor {
<a href=#92 id=92 data-nosnippet>92</a>                    <span class="kw">type </span>Value = Field;
<a href=#93 id=93 data-nosnippet>93</a>
<a href=#94 id=94 data-nosnippet>94</a>                    <span class="kw">fn </span>expecting(<span class="kw-2">&amp;</span><span class="self">self</span>, f: <span class="kw-2">&amp;mut </span>core::fmt::Formatter&lt;<span class="lifetime">'_</span>&gt;) -&gt; core::fmt::Result {
<a href=#95 id=95 data-nosnippet>95</a>                        f.write_str(<span class="string">"field identifier"</span>)
<a href=#96 id=96 data-nosnippet>96</a>                    }
<a href=#97 id=97 data-nosnippet>97</a>
<a href=#98 id=98 data-nosnippet>98</a>                    <span class="kw">fn </span>visit_str&lt;E&gt;(<span class="self">self</span>, v: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>::Value, E&gt; <span class="kw">where </span>E: <span class="kw">crate</span>::serde::de::Error {
<a href=#99 id=99 data-nosnippet>99</a>                        <span class="prelude-val">Ok</span>(<span class="kw">match </span>v {
<a href=#100 id=100 data-nosnippet>100</a>                            <span class="string">"fieldPath" </span>=&gt; Field::Key_field_path,
<a href=#101 id=101 data-nosnippet>101</a>                            <span class="string">"message" </span>=&gt; Field::Key_message,
<a href=#102 id=102 data-nosnippet>102</a>                            <span class="string">"messageExpression" </span>=&gt; Field::Key_message_expression,
<a href=#103 id=103 data-nosnippet>103</a>                            <span class="string">"optionalOldSelf" </span>=&gt; Field::Key_optional_old_self,
<a href=#104 id=104 data-nosnippet>104</a>                            <span class="string">"reason" </span>=&gt; Field::Key_reason,
<a href=#105 id=105 data-nosnippet>105</a>                            <span class="string">"rule" </span>=&gt; Field::Key_rule,
<a href=#106 id=106 data-nosnippet>106</a>                            <span class="kw">_ </span>=&gt; Field::Other,
<a href=#107 id=107 data-nosnippet>107</a>                        })
<a href=#108 id=108 data-nosnippet>108</a>                    }
<a href=#109 id=109 data-nosnippet>109</a>                }
<a href=#110 id=110 data-nosnippet>110</a>
<a href=#111 id=111 data-nosnippet>111</a>                deserializer.deserialize_identifier(Visitor)
<a href=#112 id=112 data-nosnippet>112</a>            }
<a href=#113 id=113 data-nosnippet>113</a>        }
<a href=#114 id=114 data-nosnippet>114</a>
<a href=#115 id=115 data-nosnippet>115</a>        <span class="kw">struct </span>Visitor;
<a href=#116 id=116 data-nosnippet>116</a>
<a href=#117 id=117 data-nosnippet>117</a>        <span class="kw">impl</span>&lt;<span class="lifetime">'de</span>&gt; <span class="kw">crate</span>::serde::de::Visitor&lt;<span class="lifetime">'de</span>&gt; <span class="kw">for </span>Visitor {
<a href=#118 id=118 data-nosnippet>118</a>            <span class="kw">type </span>Value = ValidationRule;
<a href=#119 id=119 data-nosnippet>119</a>
<a href=#120 id=120 data-nosnippet>120</a>            <span class="kw">fn </span>expecting(<span class="kw-2">&amp;</span><span class="self">self</span>, f: <span class="kw-2">&amp;mut </span>core::fmt::Formatter&lt;<span class="lifetime">'_</span>&gt;) -&gt; core::fmt::Result {
<a href=#121 id=121 data-nosnippet>121</a>                f.write_str(<span class="string">"ValidationRule"</span>)
<a href=#122 id=122 data-nosnippet>122</a>            }
<a href=#123 id=123 data-nosnippet>123</a>
<a href=#124 id=124 data-nosnippet>124</a>            <span class="kw">fn </span>visit_map&lt;A&gt;(<span class="self">self</span>, <span class="kw-2">mut </span>map: A) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>::Value, A::Error&gt; <span class="kw">where </span>A: <span class="kw">crate</span>::serde::de::MapAccess&lt;<span class="lifetime">'de</span>&gt; {
<a href=#125 id=125 data-nosnippet>125</a>                <span class="kw">let </span><span class="kw-2">mut </span>value_field_path: <span class="prelude-ty">Option</span>&lt;std::string::String&gt; = <span class="prelude-val">None</span>;
<a href=#126 id=126 data-nosnippet>126</a>                <span class="kw">let </span><span class="kw-2">mut </span>value_message: <span class="prelude-ty">Option</span>&lt;std::string::String&gt; = <span class="prelude-val">None</span>;
<a href=#127 id=127 data-nosnippet>127</a>                <span class="kw">let </span><span class="kw-2">mut </span>value_message_expression: <span class="prelude-ty">Option</span>&lt;std::string::String&gt; = <span class="prelude-val">None</span>;
<a href=#128 id=128 data-nosnippet>128</a>                <span class="kw">let </span><span class="kw-2">mut </span>value_optional_old_self: <span class="prelude-ty">Option</span>&lt;bool&gt; = <span class="prelude-val">None</span>;
<a href=#129 id=129 data-nosnippet>129</a>                <span class="kw">let </span><span class="kw-2">mut </span>value_reason: <span class="prelude-ty">Option</span>&lt;std::string::String&gt; = <span class="prelude-val">None</span>;
<a href=#130 id=130 data-nosnippet>130</a>                <span class="kw">let </span><span class="kw-2">mut </span>value_rule: <span class="prelude-ty">Option</span>&lt;std::string::String&gt; = <span class="prelude-val">None</span>;
<a href=#131 id=131 data-nosnippet>131</a>
<a href=#132 id=132 data-nosnippet>132</a>                <span class="kw">while let </span><span class="prelude-val">Some</span>(key) = <span class="kw">crate</span>::serde::de::MapAccess::next_key::&lt;Field&gt;(<span class="kw-2">&amp;mut </span>map)<span class="question-mark">? </span>{
<a href=#133 id=133 data-nosnippet>133</a>                    <span class="kw">match </span>key {
<a href=#134 id=134 data-nosnippet>134</a>                        Field::Key_field_path =&gt; value_field_path = <span class="kw">crate</span>::serde::de::MapAccess::next_value(<span class="kw-2">&amp;mut </span>map)<span class="question-mark">?</span>,
<a href=#135 id=135 data-nosnippet>135</a>                        Field::Key_message =&gt; value_message = <span class="kw">crate</span>::serde::de::MapAccess::next_value(<span class="kw-2">&amp;mut </span>map)<span class="question-mark">?</span>,
<a href=#136 id=136 data-nosnippet>136</a>                        Field::Key_message_expression =&gt; value_message_expression = <span class="kw">crate</span>::serde::de::MapAccess::next_value(<span class="kw-2">&amp;mut </span>map)<span class="question-mark">?</span>,
<a href=#137 id=137 data-nosnippet>137</a>                        Field::Key_optional_old_self =&gt; value_optional_old_self = <span class="kw">crate</span>::serde::de::MapAccess::next_value(<span class="kw-2">&amp;mut </span>map)<span class="question-mark">?</span>,
<a href=#138 id=138 data-nosnippet>138</a>                        Field::Key_reason =&gt; value_reason = <span class="kw">crate</span>::serde::de::MapAccess::next_value(<span class="kw-2">&amp;mut </span>map)<span class="question-mark">?</span>,
<a href=#139 id=139 data-nosnippet>139</a>                        Field::Key_rule =&gt; value_rule = <span class="kw">crate</span>::serde::de::MapAccess::next_value(<span class="kw-2">&amp;mut </span>map)<span class="question-mark">?</span>,
<a href=#140 id=140 data-nosnippet>140</a>                        Field::Other =&gt; { <span class="kw">let _</span>: <span class="kw">crate</span>::serde::de::IgnoredAny = <span class="kw">crate</span>::serde::de::MapAccess::next_value(<span class="kw-2">&amp;mut </span>map)<span class="question-mark">?</span>; },
<a href=#141 id=141 data-nosnippet>141</a>                    }
<a href=#142 id=142 data-nosnippet>142</a>                }
<a href=#143 id=143 data-nosnippet>143</a>
<a href=#144 id=144 data-nosnippet>144</a>                <span class="prelude-val">Ok</span>(ValidationRule {
<a href=#145 id=145 data-nosnippet>145</a>                    field_path: value_field_path,
<a href=#146 id=146 data-nosnippet>146</a>                    message: value_message,
<a href=#147 id=147 data-nosnippet>147</a>                    message_expression: value_message_expression,
<a href=#148 id=148 data-nosnippet>148</a>                    optional_old_self: value_optional_old_self,
<a href=#149 id=149 data-nosnippet>149</a>                    reason: value_reason,
<a href=#150 id=150 data-nosnippet>150</a>                    rule: value_rule.unwrap_or_default(),
<a href=#151 id=151 data-nosnippet>151</a>                })
<a href=#152 id=152 data-nosnippet>152</a>            }
<a href=#153 id=153 data-nosnippet>153</a>        }
<a href=#154 id=154 data-nosnippet>154</a>
<a href=#155 id=155 data-nosnippet>155</a>        deserializer.deserialize_struct(
<a href=#156 id=156 data-nosnippet>156</a>            <span class="string">"ValidationRule"</span>,
<a href=#157 id=157 data-nosnippet>157</a>            <span class="kw-2">&amp;</span>[
<a href=#158 id=158 data-nosnippet>158</a>                <span class="string">"fieldPath"</span>,
<a href=#159 id=159 data-nosnippet>159</a>                <span class="string">"message"</span>,
<a href=#160 id=160 data-nosnippet>160</a>                <span class="string">"messageExpression"</span>,
<a href=#161 id=161 data-nosnippet>161</a>                <span class="string">"optionalOldSelf"</span>,
<a href=#162 id=162 data-nosnippet>162</a>                <span class="string">"reason"</span>,
<a href=#163 id=163 data-nosnippet>163</a>                <span class="string">"rule"</span>,
<a href=#164 id=164 data-nosnippet>164</a>            ],
<a href=#165 id=165 data-nosnippet>165</a>            Visitor,
<a href=#166 id=166 data-nosnippet>166</a>        )
<a href=#167 id=167 data-nosnippet>167</a>    }
<a href=#168 id=168 data-nosnippet>168</a>}
<a href=#169 id=169 data-nosnippet>169</a>
<a href=#170 id=170 data-nosnippet>170</a><span class="kw">impl </span><span class="kw">crate</span>::serde::Serialize <span class="kw">for </span>ValidationRule {
<a href=#171 id=171 data-nosnippet>171</a>    <span class="kw">fn </span>serialize&lt;S&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, serializer: S) -&gt; <span class="prelude-ty">Result</span>&lt;S::Ok, S::Error&gt; <span class="kw">where </span>S: <span class="kw">crate</span>::serde::Serializer {
<a href=#172 id=172 data-nosnippet>172</a>        <span class="kw">let </span><span class="kw-2">mut </span>state = serializer.serialize_struct(
<a href=#173 id=173 data-nosnippet>173</a>            <span class="string">"ValidationRule"</span>,
<a href=#174 id=174 data-nosnippet>174</a>            <span class="number">1 </span>+
<a href=#175 id=175 data-nosnippet>175</a>            <span class="self">self</span>.field_path.as_ref().map_or(<span class="number">0</span>, |<span class="kw">_</span>| <span class="number">1</span>) +
<a href=#176 id=176 data-nosnippet>176</a>            <span class="self">self</span>.message.as_ref().map_or(<span class="number">0</span>, |<span class="kw">_</span>| <span class="number">1</span>) +
<a href=#177 id=177 data-nosnippet>177</a>            <span class="self">self</span>.message_expression.as_ref().map_or(<span class="number">0</span>, |<span class="kw">_</span>| <span class="number">1</span>) +
<a href=#178 id=178 data-nosnippet>178</a>            <span class="self">self</span>.optional_old_self.as_ref().map_or(<span class="number">0</span>, |<span class="kw">_</span>| <span class="number">1</span>) +
<a href=#179 id=179 data-nosnippet>179</a>            <span class="self">self</span>.reason.as_ref().map_or(<span class="number">0</span>, |<span class="kw">_</span>| <span class="number">1</span>),
<a href=#180 id=180 data-nosnippet>180</a>        )<span class="question-mark">?</span>;
<a href=#181 id=181 data-nosnippet>181</a>        <span class="kw">if let </span><span class="prelude-val">Some</span>(value) = <span class="kw-2">&amp;</span><span class="self">self</span>.field_path {
<a href=#182 id=182 data-nosnippet>182</a>            <span class="kw">crate</span>::serde::ser::SerializeStruct::serialize_field(<span class="kw-2">&amp;mut </span>state, <span class="string">"fieldPath"</span>, value)<span class="question-mark">?</span>;
<a href=#183 id=183 data-nosnippet>183</a>        }
<a href=#184 id=184 data-nosnippet>184</a>        <span class="kw">if let </span><span class="prelude-val">Some</span>(value) = <span class="kw-2">&amp;</span><span class="self">self</span>.message {
<a href=#185 id=185 data-nosnippet>185</a>            <span class="kw">crate</span>::serde::ser::SerializeStruct::serialize_field(<span class="kw-2">&amp;mut </span>state, <span class="string">"message"</span>, value)<span class="question-mark">?</span>;
<a href=#186 id=186 data-nosnippet>186</a>        }
<a href=#187 id=187 data-nosnippet>187</a>        <span class="kw">if let </span><span class="prelude-val">Some</span>(value) = <span class="kw-2">&amp;</span><span class="self">self</span>.message_expression {
<a href=#188 id=188 data-nosnippet>188</a>            <span class="kw">crate</span>::serde::ser::SerializeStruct::serialize_field(<span class="kw-2">&amp;mut </span>state, <span class="string">"messageExpression"</span>, value)<span class="question-mark">?</span>;
<a href=#189 id=189 data-nosnippet>189</a>        }
<a href=#190 id=190 data-nosnippet>190</a>        <span class="kw">if let </span><span class="prelude-val">Some</span>(value) = <span class="kw-2">&amp;</span><span class="self">self</span>.optional_old_self {
<a href=#191 id=191 data-nosnippet>191</a>            <span class="kw">crate</span>::serde::ser::SerializeStruct::serialize_field(<span class="kw-2">&amp;mut </span>state, <span class="string">"optionalOldSelf"</span>, value)<span class="question-mark">?</span>;
<a href=#192 id=192 data-nosnippet>192</a>        }
<a href=#193 id=193 data-nosnippet>193</a>        <span class="kw">if let </span><span class="prelude-val">Some</span>(value) = <span class="kw-2">&amp;</span><span class="self">self</span>.reason {
<a href=#194 id=194 data-nosnippet>194</a>            <span class="kw">crate</span>::serde::ser::SerializeStruct::serialize_field(<span class="kw-2">&amp;mut </span>state, <span class="string">"reason"</span>, value)<span class="question-mark">?</span>;
<a href=#195 id=195 data-nosnippet>195</a>        }
<a href=#196 id=196 data-nosnippet>196</a>        <span class="kw">crate</span>::serde::ser::SerializeStruct::serialize_field(<span class="kw-2">&amp;mut </span>state, <span class="string">"rule"</span>, <span class="kw-2">&amp;</span><span class="self">self</span>.rule)<span class="question-mark">?</span>;
<a href=#197 id=197 data-nosnippet>197</a>        <span class="kw">crate</span>::serde::ser::SerializeStruct::end(state)
<a href=#198 id=198 data-nosnippet>198</a>    }
<a href=#199 id=199 data-nosnippet>199</a>}
<a href=#200 id=200 data-nosnippet>200</a>
<a href=#201 id=201 data-nosnippet>201</a><span class="attr">#[cfg(feature = <span class="string">"schemars"</span>)]
<a href=#202 id=202 data-nosnippet>202</a></span><span class="kw">impl </span><span class="kw">crate</span>::schemars::JsonSchema <span class="kw">for </span>ValidationRule {
<a href=#203 id=203 data-nosnippet>203</a>    <span class="kw">fn </span>schema_name() -&gt; std::borrow::Cow&lt;<span class="lifetime">'static</span>, str&gt; {
<a href=#204 id=204 data-nosnippet>204</a>        <span class="string">"io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.ValidationRule"</span>.into()
<a href=#205 id=205 data-nosnippet>205</a>    }
<a href=#206 id=206 data-nosnippet>206</a>
<a href=#207 id=207 data-nosnippet>207</a>    <span class="kw">fn </span>json_schema(__gen: <span class="kw-2">&amp;mut </span><span class="kw">crate</span>::schemars::SchemaGenerator) -&gt; <span class="kw">crate</span>::schemars::Schema {
<a href=#208 id=208 data-nosnippet>208</a>        <span class="macro">crate::schemars::json_schema!</span>({
<a href=#209 id=209 data-nosnippet>209</a>            <span class="string">"description"</span>: <span class="string">"ValidationRule describes a validation rule written in the CEL expression language."</span>,
<a href=#210 id=210 data-nosnippet>210</a>            <span class="string">"type"</span>: <span class="string">"object"</span>,
<a href=#211 id=211 data-nosnippet>211</a>            <span class="string">"properties"</span>: {
<a href=#212 id=212 data-nosnippet>212</a>                <span class="string">"fieldPath"</span>: {
<a href=#213 id=213 data-nosnippet>213</a>                    <span class="string">"description"</span>: <span class="string">"fieldPath represents the field path returned when the validation fails. It must be a relative JSON path (i.e. with array notation) scoped to the location of this x-kubernetes-validations extension in the schema and refer to an existing field. e.g. when validation checks if a specific attribute `foo` under a map `testMap`, the fieldPath could be set to `.testMap.foo` If the validation checks two lists must have unique attributes, the fieldPath could be set to either of the list: e.g. `.testList` It does not support list numeric index. It supports child operation to refer to an existing field currently. Refer to [JSONPath support in Kubernetes](https://kubernetes.io/docs/reference/kubectl/jsonpath/) for more info. Numeric index of array is not supported. For field name which contains special characters, use `['specialName']` to refer the field name. e.g. for attribute `foo.34$` appears in a list `testList`, the fieldPath could be set to `.testList['foo.34$']`"</span>,
<a href=#214 id=214 data-nosnippet>214</a>                    <span class="string">"type"</span>: <span class="string">"string"</span>,
<a href=#215 id=215 data-nosnippet>215</a>                },
<a href=#216 id=216 data-nosnippet>216</a>                <span class="string">"message"</span>: {
<a href=#217 id=217 data-nosnippet>217</a>                    <span class="string">"description"</span>: <span class="string">"Message represents the message displayed when validation fails. The message is required if the Rule contains line breaks. The message must not contain line breaks. If unset, the message is \"failed rule: {Rule}\". e.g. \"must be a URL with the host matching spec.host\""</span>,
<a href=#218 id=218 data-nosnippet>218</a>                    <span class="string">"type"</span>: <span class="string">"string"</span>,
<a href=#219 id=219 data-nosnippet>219</a>                },
<a href=#220 id=220 data-nosnippet>220</a>                <span class="string">"messageExpression"</span>: {
<a href=#221 id=221 data-nosnippet>221</a>                    <span class="string">"description"</span>: <span class="string">"MessageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails. Since messageExpression is used as a failure message, it must evaluate to a string. If both message and messageExpression are present on a rule, then messageExpression will be used if validation fails. If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged. messageExpression has access to all the same variables as the rule; the only difference is the return type. Example: \"x must be less than max (\"+string(self.max)+\")\""</span>,
<a href=#222 id=222 data-nosnippet>222</a>                    <span class="string">"type"</span>: <span class="string">"string"</span>,
<a href=#223 id=223 data-nosnippet>223</a>                },
<a href=#224 id=224 data-nosnippet>224</a>                <span class="string">"optionalOldSelf"</span>: {
<a href=#225 id=225 data-nosnippet>225</a>                    <span class="string">"description"</span>: <span class="string">"optionalOldSelf is used to opt a transition rule into evaluation even when the object is first created, or if the old object is missing the value.\n\nWhen enabled `oldSelf` will be a CEL optional whose value will be `None` if there is no old value, or when the object is initially created.\n\nYou may check for presence of oldSelf using `oldSelf.hasValue()` and unwrap it after checking using `oldSelf.value()`. Check the CEL documentation for Optional types for more information: https://pkg.go.dev/github.com/google/cel-go/cel#OptionalTypes\n\nMay not be set unless `oldSelf` is used in `rule`."</span>,
<a href=#226 id=226 data-nosnippet>226</a>                    <span class="string">"type"</span>: <span class="string">"boolean"</span>,
<a href=#227 id=227 data-nosnippet>227</a>                },
<a href=#228 id=228 data-nosnippet>228</a>                <span class="string">"reason"</span>: {
<a href=#229 id=229 data-nosnippet>229</a>                    <span class="string">"description"</span>: <span class="string">"reason provides a machine-readable validation failure reason that is returned to the caller when a request fails this validation rule. The HTTP status code returned to the caller will match the reason of the reason of the first failed validation rule. The currently supported reasons are: \"FieldValueInvalid\", \"FieldValueForbidden\", \"FieldValueRequired\", \"FieldValueDuplicate\". If not set, default to use \"FieldValueInvalid\". All future added reasons must be accepted by clients when reading this value and unknown reasons should be treated as FieldValueInvalid."</span>,
<a href=#230 id=230 data-nosnippet>230</a>                    <span class="string">"type"</span>: <span class="string">"string"</span>,
<a href=#231 id=231 data-nosnippet>231</a>                },
<a href=#232 id=232 data-nosnippet>232</a>                <span class="string">"rule"</span>: {
<a href=#233 id=233 data-nosnippet>233</a>                    <span class="string">"description"</span>: <span class="string">"Rule represents the expression which will be evaluated by CEL. ref: https://github.com/google/cel-spec The Rule is scoped to the location of the x-kubernetes-validations extension in the schema. The `self` variable in the CEL expression is bound to the scoped value. Example: - Rule scoped to the root of a resource with a status subresource: {\"rule\": \"self.status.actual &lt;= self.spec.maxDesired\"}\n\nIf the Rule is scoped to an object with properties, the accessible properties of the object are field selectable via `self.field` and field presence can be checked via `has(self.field)`. Null valued fields are treated as absent fields in CEL expressions. If the Rule is scoped to an object with additionalProperties (i.e. a map) the value of the map are accessible via `self[mapKey]`, map containment can be checked via `mapKey in self` and all entries of the map are accessible via CEL macros and functions such as `self.all(...)`. If the Rule is scoped to an array, the elements of the array are accessible via `self[i]` and also by macros and functions. If the Rule is scoped to a scalar, `self` is bound to the scalar value. Examples: - Rule scoped to a map of objects: {\"rule\": \"self.components['Widget'].priority &lt; 10\"} - Rule scoped to a list of integers: {\"rule\": \"self.values.all(value, value &gt;= 0 &amp;&amp; value &lt; 100)\"} - Rule scoped to a string value: {\"rule\": \"self.startsWith('kube')\"}\n\nThe `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the object and from any x-kubernetes-embedded-resource annotated objects. No other metadata properties are accessible.\n\nUnknown data preserved in custom resources via x-kubernetes-preserve-unknown-fields is not accessible in CEL expressions. This includes: - Unknown field values that are preserved by object schemas with x-kubernetes-preserve-unknown-fields. - Object properties where the property schema is of an \"unknown type\". An \"unknown type\" is recursively defined as:\n  - A schema with no type and x-kubernetes-preserve-unknown-fields set to true\n  - An array where the items schema is of an \"unknown type\"\n  - An object where the additionalProperties schema is of an \"unknown type\"\n\nOnly property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible. Accessible property names are escaped according to the following rules when accessed in the expression: - '__' escapes to '__underscores__' - '.' escapes to '__dot__' - '-' escapes to '__dash__' - '/' escapes to '__slash__' - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:\n\t  \"true\", \"false\", \"null\", \"in\", \"as\", \"break\", \"const\", \"continue\", \"else\", \"for\", \"function\", \"if\",\n\t  \"import\", \"let\", \"loop\", \"package\", \"namespace\", \"return\".\nExamples:\n  - Rule accessing a property named \"namespace\": {\"rule\": \"self.__namespace__ &gt; 0\"}\n  - Rule accessing a property named \"x-prop\": {\"rule\": \"self.x__dash__prop &gt; 0\"}\n  - Rule accessing a property named \"redact__d\": {\"rule\": \"self.redact__underscores__d &gt; 0\"}\n\nEquality on arrays with x-kubernetes-list-type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1]. Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:\n  - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and\n    non-intersecting elements in `Y` are appended, retaining their partial order.\n  - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values\n    are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with\n    non-intersecting keys are appended, retaining their partial order.\n\nIf `rule` makes use of the `oldSelf` variable it is implicitly a `transition rule`.\n\nBy default, the `oldSelf` variable is the same type as `self`. When `optionalOldSelf` is true, the `oldSelf` variable is a CEL optional\n variable whose value() is the same type as `self`.\nSee the documentation for the `optionalOldSelf` field for details.\n\nTransition rules by default are applied only on UPDATE requests and are skipped if an old value could not be found. You can opt a transition rule into unconditional evaluation by setting `optionalOldSelf` to true."</span>,
<a href=#234 id=234 data-nosnippet>234</a>                    <span class="string">"type"</span>: <span class="string">"string"</span>,
<a href=#235 id=235 data-nosnippet>235</a>                },
<a href=#236 id=236 data-nosnippet>236</a>            },
<a href=#237 id=237 data-nosnippet>237</a>            <span class="string">"required"</span>: [
<a href=#238 id=238 data-nosnippet>238</a>                <span class="string">"rule"</span>,
<a href=#239 id=239 data-nosnippet>239</a>            ],
<a href=#240 id=240 data-nosnippet>240</a>        })
<a href=#241 id=241 data-nosnippet>241</a>    }
<a href=#242 id=242 data-nosnippet>242</a>}</code></pre></div></section></main></body></html>