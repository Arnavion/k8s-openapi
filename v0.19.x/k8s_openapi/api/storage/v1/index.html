<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `v1` mod in crate `k8s_openapi`."><title>k8s_openapi::api::storage::v1 - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="k8s_openapi" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0-nightly (04abc370b 2023-07-28)" data-channel="nightly" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-6d2c9675f3d09c26.css" data-theme-dark-css="dark-45ceb8f2e522f4d1.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../../../../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../../../../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../../static.files/light-6d2c9675f3d09c26.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../../static.files/dark-45ceb8f2e522f4d1.css"><link rel="stylesheet" href="../../../../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../../k8s_openapi/index.html"><img class="rust-logo" src="../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../../k8s_openapi/index.html"><img class="rust-logo" src="../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module v1</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../../index.html">k8s_openapi</a>::<wbr><a href="../../index.html">api</a>::<wbr><a href="../index.html">storage</a>::<wbr><a class="mod" href="#">v1</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../../src/k8s_openapi/v1_27/api/storage/v1/mod.rs.html#2-48">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.CSIDriver.html" title="struct k8s_openapi::api::storage::v1::CSIDriver">CSIDriver</a></div><div class="desc docblock-short">CSIDriver captures information about a Container Storage Interface (CSI) volume driver deployed on the cluster. Kubernetes attach detach controller uses this object to determine whether attach is required. Kubelet uses this object to determine whether pod information needs to be passed on mount. CSIDriver objects are non-namespaced.</div></li><li><div class="item-name"><a class="struct" href="struct.CSIDriverSpec.html" title="struct k8s_openapi::api::storage::v1::CSIDriverSpec">CSIDriverSpec</a></div><div class="desc docblock-short">CSIDriverSpec is the specification of a CSIDriver.</div></li><li><div class="item-name"><a class="struct" href="struct.CSINode.html" title="struct k8s_openapi::api::storage::v1::CSINode">CSINode</a></div><div class="desc docblock-short">CSINode holds information about all CSI drivers installed on a node. CSI drivers do not need to create the CSINode object directly. As long as they use the node-driver-registrar sidecar container, the kubelet will automatically populate the CSINode object for the CSI driver as part of kubelet plugin registration. CSINode has the same name as a node. If the object is missing, it means either there are no CSI Drivers available on the node, or the Kubelet version is low enough that it doesn’t create this object. CSINode has an OwnerReference that points to the corresponding node object.</div></li><li><div class="item-name"><a class="struct" href="struct.CSINodeDriver.html" title="struct k8s_openapi::api::storage::v1::CSINodeDriver">CSINodeDriver</a></div><div class="desc docblock-short">CSINodeDriver holds information about the specification of one CSI driver installed on a node</div></li><li><div class="item-name"><a class="struct" href="struct.CSINodeSpec.html" title="struct k8s_openapi::api::storage::v1::CSINodeSpec">CSINodeSpec</a></div><div class="desc docblock-short">CSINodeSpec holds information about the specification of all CSI drivers installed on a node</div></li><li><div class="item-name"><a class="struct" href="struct.CSIStorageCapacity.html" title="struct k8s_openapi::api::storage::v1::CSIStorageCapacity">CSIStorageCapacity</a></div><div class="desc docblock-short">CSIStorageCapacity stores the result of one CSI GetCapacity call. For a given StorageClass, this describes the available capacity in a particular topology segment.  This can be used when considering where to instantiate new PersistentVolumes.</div></li><li><div class="item-name"><a class="struct" href="struct.StorageClass.html" title="struct k8s_openapi::api::storage::v1::StorageClass">StorageClass</a></div><div class="desc docblock-short">StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.</div></li><li><div class="item-name"><a class="struct" href="struct.TokenRequest.html" title="struct k8s_openapi::api::storage::v1::TokenRequest">TokenRequest</a></div><div class="desc docblock-short">TokenRequest contains parameters of a service account token.</div></li><li><div class="item-name"><a class="struct" href="struct.VolumeAttachment.html" title="struct k8s_openapi::api::storage::v1::VolumeAttachment">VolumeAttachment</a></div><div class="desc docblock-short">VolumeAttachment captures the intent to attach or detach the specified volume to/from the specified node.</div></li><li><div class="item-name"><a class="struct" href="struct.VolumeAttachmentSource.html" title="struct k8s_openapi::api::storage::v1::VolumeAttachmentSource">VolumeAttachmentSource</a></div><div class="desc docblock-short">VolumeAttachmentSource represents a volume that should be attached. Right now only PersistenVolumes can be attached via external attacher, in future we may allow also inline volumes in pods. Exactly one member can be set.</div></li><li><div class="item-name"><a class="struct" href="struct.VolumeAttachmentSpec.html" title="struct k8s_openapi::api::storage::v1::VolumeAttachmentSpec">VolumeAttachmentSpec</a></div><div class="desc docblock-short">VolumeAttachmentSpec is the specification of a VolumeAttachment request.</div></li><li><div class="item-name"><a class="struct" href="struct.VolumeAttachmentStatus.html" title="struct k8s_openapi::api::storage::v1::VolumeAttachmentStatus">VolumeAttachmentStatus</a></div><div class="desc docblock-short">VolumeAttachmentStatus is the status of a VolumeAttachment request.</div></li><li><div class="item-name"><a class="struct" href="struct.VolumeError.html" title="struct k8s_openapi::api::storage::v1::VolumeError">VolumeError</a></div><div class="desc docblock-short">VolumeError captures an error encountered during a volume operation.</div></li><li><div class="item-name"><a class="struct" href="struct.VolumeNodeResources.html" title="struct k8s_openapi::api::storage::v1::VolumeNodeResources">VolumeNodeResources</a></div><div class="desc docblock-short">VolumeNodeResources is a set of resource limits for scheduling of volumes.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.ReadCSIDriverResponse.html" title="enum k8s_openapi::api::storage::v1::ReadCSIDriverResponse">ReadCSIDriverResponse</a></div><div class="desc docblock-short">Use <code>&lt;ReadCSIDriverResponse as Response&gt;::try_from_parts</code> to parse the HTTP response body of <a href="struct.CSIDriver.html#method.read" title="associated function k8s_openapi::api::storage::v1::CSIDriver::read"><code>CSIDriver::read</code></a></div></li><li><div class="item-name"><a class="enum" href="enum.ReadCSINodeResponse.html" title="enum k8s_openapi::api::storage::v1::ReadCSINodeResponse">ReadCSINodeResponse</a></div><div class="desc docblock-short">Use <code>&lt;ReadCSINodeResponse as Response&gt;::try_from_parts</code> to parse the HTTP response body of <a href="struct.CSINode.html#method.read" title="associated function k8s_openapi::api::storage::v1::CSINode::read"><code>CSINode::read</code></a></div></li><li><div class="item-name"><a class="enum" href="enum.ReadCSIStorageCapacityResponse.html" title="enum k8s_openapi::api::storage::v1::ReadCSIStorageCapacityResponse">ReadCSIStorageCapacityResponse</a></div><div class="desc docblock-short">Use <code>&lt;ReadCSIStorageCapacityResponse as Response&gt;::try_from_parts</code> to parse the HTTP response body of <a href="struct.CSIStorageCapacity.html#method.read" title="associated function k8s_openapi::api::storage::v1::CSIStorageCapacity::read"><code>CSIStorageCapacity::read</code></a></div></li><li><div class="item-name"><a class="enum" href="enum.ReadStorageClassResponse.html" title="enum k8s_openapi::api::storage::v1::ReadStorageClassResponse">ReadStorageClassResponse</a></div><div class="desc docblock-short">Use <code>&lt;ReadStorageClassResponse as Response&gt;::try_from_parts</code> to parse the HTTP response body of <a href="struct.StorageClass.html#method.read" title="associated function k8s_openapi::api::storage::v1::StorageClass::read"><code>StorageClass::read</code></a></div></li><li><div class="item-name"><a class="enum" href="enum.ReadVolumeAttachmentResponse.html" title="enum k8s_openapi::api::storage::v1::ReadVolumeAttachmentResponse">ReadVolumeAttachmentResponse</a></div><div class="desc docblock-short">Use <code>&lt;ReadVolumeAttachmentResponse as Response&gt;::try_from_parts</code> to parse the HTTP response body of <a href="struct.VolumeAttachment.html#method.read" title="associated function k8s_openapi::api::storage::v1::VolumeAttachment::read"><code>VolumeAttachment::read</code></a></div></li><li><div class="item-name"><a class="enum" href="enum.ReadVolumeAttachmentStatusResponse.html" title="enum k8s_openapi::api::storage::v1::ReadVolumeAttachmentStatusResponse">ReadVolumeAttachmentStatusResponse</a></div><div class="desc docblock-short">Use <code>&lt;ReadVolumeAttachmentStatusResponse as Response&gt;::try_from_parts</code> to parse the HTTP response body of <a href="struct.VolumeAttachment.html#method.read_status" title="associated function k8s_openapi::api::storage::v1::VolumeAttachment::read_status"><code>VolumeAttachment::read_status</code></a></div></li></ul></section></div></main></body></html>